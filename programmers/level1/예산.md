# 예산

<br/>

## **📝문제 설명**

<br/>

S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.

물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.

부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.

<br/>

### **⚠제한사항**

<br/>

- d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.
- d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.
- budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.

<br/>

### **입출력 예**

<br/>

d |	budget |	result
--|--------|--------
[1,3,2,5,4] |	9 |	3
[2,2,3,3] |	10 |	4

<br/>


## **🧐CODE REVIEW**
***

<br/>

### **😫나의 오답풀이**

<br/>

```python
from itertools import combinations


def solution(d, budget):
    for i in range(len(d), 0, -1):
        depart = list(combinations(d, i))
        for j in range(len(depart)):
            if sum(depart[j]) <= budget:
                return i
```

<br/>

#### **📝해설**

<br/>

컴비네이션으로 예산이 필요한 부서를 골라서 예산을 넘지 않는지만 판단해주면 될 것으로 생각해서 컴비네이션을 사용했다. 그런데 3번 문제 틀림, 절반 이상 제한 시간으로 오답이 나왔다. 컴비네이션을 사용하려고 했던 것이 문제였다.

<br/>

> for i in combinations(d,cnt):
이 부분이 **압도적**으로 시간을 잡아먹습니다.
`combinations(d,cnt)`
는 리스트 `d` 에서 `cnt` 개수 만큼의 원소를 뽑아낼 수 있는 모든 경우의 수를 순회하게 해 줍니다.
`d` 의 원소의 개수를 `l` 이라고 할 때, 출력하는 원소의 개수는 다음과 같습니다.
`l! / (cnt! * (l - cnt!))`
만약 l의 원소의 개수가 100개이고, cnt가 현재 5라고 친다면,
`(100 * 99 * 98 * 97* 96) / (5*4*3*2*1)`
가지의 수(= **75,287,520**)를 모두 순회하고 있다는 의미입니다.
그런데 이 경우의 수를 1부터 d의 길이까지 반복한다고 하면, 계산량은 어마어마해집니다.
combinations를 쓰지 않고 푸는 방법을 생각해보세요.
>https://programmers.co.kr/questions/9692 (by SoftVanilla)

<br/>

### **🧾나의 풀이**

<br/>

```python
def solution(d, budget):
    d.sort()
    for i in range(len(d)):
        if sum(d[:i+1]) > budget:
            return i
    return i+1
```

<br/>

#### **📝해설**

<br/>

문제를 잘 보면 가장 많은 부서를 지원하려면 예산 신청이 가장 적은 부서부터 지원해주어야한다. 그 말은 **d**를 **sort()** 해주기만 하면 쉽게 풀수 있는 문제라는 것이다. 또한 **len(d)가 1일 경우**도 처리해주어야 하는데 for문이 끝나고 return을 두어서 처리했다.

<br/>

### **🔖정리**

<br/>

1. 풀이방식이 코드작성을 효율적일지라도 코드 자체가 비효율적으로 문제를 해결하고 있지는 않은지 다시 생각해보자🤔

<br/>

