# 성격 유형 검사하기

## **📝문제 설명**

나만의 카카오 성격 유형 검사지를 만들려고 합니다.
성격 유형 검사는 다음과 같은 4개 지표로 성격 유형을 구분합니다. 성격은 각 지표에서 두 유형 중 하나로 결정됩니다.

| 지표번호 | 성격유형               |
| -------- | ---------------------- |
| 1번 지표 | 라이언형(R), 튜브형(T) |
| 2번 지표 | 콘형(C), 프로도형(F)   |
| 3번 지표 | 제이지형(J), 무지형(M) |
| 4번 지표 | 어피치형(A), 네오형(N) |

4개의 지표가 있으므로 성격 유형은 총 16(=2 x 2 x 2 x 2)가지가 나올 수 있습니다. 예를 들어, "RFMN"이나 "TCMA"와 같은 성격 유형이 있습니다.

검사지에는 총 `n`개의 질문이 있고, 각 질문에는 아래와 같은 7개의 선택지가 있습니다.

- 매우 비동의
- 비동의
- 약간 비동의
- 모르겠음
- 약간 동의
- 동의
- 매우 동의

각 질문은 1가지 지표로 성격 유형 점수를 판단합니다.

예를 들어, 어떤 한 질문에서 4번 지표로 아래 표처럼 점수를 매길 수 있습니다.

| 선택지      | 성격 유형                             | 점수 |
| ----------- | ------------------------------------- | ---- |
| 매우 비동의 | 네오형                                | 3점  |
| 비동의      | 네오형                                | 2점  |
| 약간 비동의 | 네오형                                | 1점  |
| 모르겠음    | 어떤 성격 유형도 점수를 얻지 않습니다 |
| 약간 동의   | 어피치형                              | 1점  |
| 동의        | 어피치형                              | 2점  |
| 매우 동의   | 어피치형                              | 3점  |

이때 검사자가 질문에서 `약간 동의` 선택지를 선택할 경우 어피치형(A) 성격 유형 1점을 받게 됩니다. 만약 검사자가 `매우 비동의` 선택지를 선택할 경우 네오형(N) 성격 유형 3점을 받게 됩니다.

위 예시처럼 네오형이 비동의, 어피치형이 동의인 경우만 주어지지 않고, 질문에 따라 네오형이 동의, 어피치형이 비동의인 경우도 주어질 수 있습니다.
하지만 각 선택지는 고정적인 크기의 점수를 가지고 있습니다.

- `매우 동의`나 `매우 비동의` 선택지를 선택하면 3점을 얻습니다.
- `동의`나 `비동의` 선택지를 선택하면 2점을 얻습니다.
- `약간 동의`나 `약간 비동의` 선택지를 선택하면 1점을 얻습니다.
- `모르겠음` 선택지를 선택하면 점수를 얻지 않습니다.

검사 결과는 모든 질문의 성격 유형 점수를 더하여 각 지표에서 더 높은 점수를 받은 성격 유형이 검사자의 성격 유형이라고 판단합니다. 단, 하나의 지표에서 각 성격 유형 점수가 같으면, 두 성격 유형 중 사전 순으로 빠른 성격 유형을 검사자의 성격 유형이라고 판단합니다.

질문마다 판단하는 지표를 담은 1차원 문자열 배열 `survey`와 검사자가 각 질문마다 선택한 선택지를 담은 1차원 정수 배열 `choices`가 매개변수로 주어집니다. 이때, 검사자의 성격 유형 검사 결과를 지표 번호 순서대로 return 하도록 solution 함수를 완성해주세요.

### **⚠제한사항**

- 1 ≤ survey의 길이 ( = n) ≤ 1,000
  - survey의 원소는 "RT", "TR", "FC", "CF", "MJ", "JM", "AN", "NA" 중 하나입니다.
  - survey[i]의 첫 번째 캐릭터는 i+1번 질문의 비동의 관련 선택지를 선택하면 받는 성격 유형을 의미합니다.
  - survey[i]의 두 번째 캐릭터는 i+1번 질문의 동의 관련 선택지를 선택하면 받는 성격 유형을 의미합니다.

- choices의 길이 = survey의 길이
  - choices[i]는 검사자가 선택한 i+1번째 질문의 선택지를 의미합니다.
  - 1 ≤ choices의 원소 ≤ 7

| choices | 뜻          |
| ------- | ----------- |
| 1       | 매우 비동의 |
| 2       | 비동의      |
| 3       | 약간 비동의 |
| 4       | 모르겠음    |
| 5       | 약간 동의   |
| 6       | 동의        |
| 7       | 매우 동의   |

### **입출력 예**

| survey                         | choices         | result |
| ------------------------------ | --------------- | ------ |
| ["AN", "CF", "MJ", "RT", "NA"] | [5, 3, 2, 7, 5] | "TCMA" |
| ["TR", "RT", "TR"]             | [7, 1, 3]       | "RCJA" |

## **🧐CODE REVIEW**

### **🧾나의 풀이**

```js
function solution(survey, choices) {
    let answer = '';
    const LENGTH = survey.length;
    
    const table = {
        R: 0,
        T: 0,
        C: 0,
        F: 0,
        J: 0,
        M: 0,
        A: 0,
        N: 0
    };
    
    const type_group = [['R', 'T'], ['C', 'F'], ['J', 'M'], ['A', 'N']];
    const point = [
        [3, 0], [2, 0], [1, 0], [0, 0], [0, 1], [0, 2], [0, 3],
    ];
    
    for(let i=0; i<LENGTH; i++){
        const type = survey[i].split('');
        const _point = point[choices[i] - 1];
        for(let j=0; j<2; j++){
            table[type[j]] += _point[j];
        }
    }
    
    for(types of type_group){
        const first = table[types[0]];
        const second = table[types[1]];
        if(first > second){
            answer += types[0];
        }else if(second > first){
            answer += types[1];
        }else {
            answer += types[0] > types[1] ? types[1] : types[0];
        }
    }
    
    return answer;
}
```

#### **📝해설**

점수 기록용 `table`, 성격타입그룹 구분용 `type_group`, 응답별 점수판 `point`로 이루어져있음

for문 덕지덕지 뭐가 굉장히 많음...

#### **😅개선점**

1. 변수 선언이 너무 많음
  
    뭔가 하드코딩으로 푼 느낌이 강함. 프로그래밍으로 푸는 방법을 생각해봐야할듯

2. for문 남용
   
    사용하는 변수의 형태에 맞는 반복문을 사용할 줄 알아야 할 것 같음.

### **다른 풀이**

```js
function solution(survey, choices) {
    const MBTI = {};
    const types = ["RT","CF","JM","AN"];

    types.forEach((type) =>
        type.split('').forEach((char) => MBTI[char] = 0)
    )

    choices.forEach((choice, index) => {
        const [disagree, agree] = survey[index];

        MBTI[choice > 4 ? agree : disagree] += Math.abs(choice - 4);
    });

    return types.map(([a, b]) => MBTI[b] > MBTI[a] ? b : a).join("");
}
```

#### **📝해설**

```js
const MBTI = {};
const types = ["RT","CF","JM","AN"];

types.forEach((type) =>
  type.split('').forEach((char) => MBTI[char] = 0)
)
```

유형 8개 각각 점수판 직접 타이핑 한 내가 부끄러워짐

```js
choices.forEach((choice, index) => {
  const [disagree, agree] = survey[index];

  MBTI[choice > 4 ? agree : disagree] += Math.abs(choice - 4);
});
```

for each구문 사용법이 기가막히게 깔끔함. 

부정형 긍정형 타입을 각각 나눠받아서 숫자 4를 기준으로 다르게 처리해준 것도 인상 깊음.

```js
return types.map(([a, b]) => MBTI[b] > MBTI[a] ? b : a).join("");
```

마지막 return 값에서 유형별로 높은 값을 골라서 문자열 합쳐서 출력하는 거까지 완벽

### **🔖정리**

1. for-each를 잘쓰자
2. 하드코딩 타이핑하지말고 프로그래밍하자

## 📚참고 사이트

- **[Javascript 객체(object)의 키(key)와 값(value)을 배열로 얻기]**<br/>
http://www.gisdeveloper.co.kr/?p=11005
