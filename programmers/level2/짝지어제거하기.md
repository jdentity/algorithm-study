# 문제 제목

<br/>

## **📝문제 설명**
***

<br/>

짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.

예를 들어, 문자열 S = `baabaa` 라면

b aa baa → bb aa → aa →

의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.

<br/>

### **⚠제한사항**

<br/>

- 문자열의 길이 : 1,000,000이하의 자연수
- 문자열은 모두 소문자로 이루어져 있습니다.

<br/>

### **입출력 예**

<br/>

s	| result
--|-------
baabaa |	1
cdcd |	0

<br/>


## **🧐CODE REVIEW**
***

<br/>

### **😫나의 오답 풀이**

<br/>

```python
def solution(s):
    answer = -1
    i = 0
    while i < len(s)-1:
        if s[i] == s[i+1]:
            s = s[:i] + s[i+2:]
            i = max(0, i-1)
        else:
            i += 1
    if s:
        return 0
    else:
        return 1
```

<br/>

#### **📝해설**

<br/>

정확성 테스트는 전부 맞았지만, 효율성 테스트는 전부 틀렸다. 런타임을 너무 많이 잡아 먹는 것 같다.

<br/>

#### **😅개선점**

<br/>

1. 문자열 슬라이싱

문자열을 슬라이싱하는 부분에서 런타임을 많이 잡아 먹는 것 같아서 필요한 부분만 다른 배열로 옮겨주는 방식으로 바꿔보려고 한다.

```python
def solution(s):
    _s = []
    for char in s:
        if _s:
            if _s[-1] == char:
                _s.pop()
            else:
                _s.append(char)
        else:
            _s.append(char)
    if _s:
        return 0
    else:
        return 1
```

<br/>

위에 처음 코드를 작성할 때 불편했던 점은 index를 상황에 따라서 바꿔 줘야한다는 점과 마지막 index에서 index error가 나지 않도록 신경 써줘야한다는 점이었는데 **스택**을 사용한다면 위에서 불편했던 방식을 모두 해결할 수 있다. 스택 내부에 아무것도 들어있지 않은 경우에 대해서만 처리해주면 된다. 그렇게 되면 논리적으로 문제 풀이도 아주 쉽다.

위에서 문자열 slicing을 사용하던 것과 효율성도 비교할 수 없을 정도로 좋아진다.

도저히 모르겠어서 구글찬스를 사용했다. 😓

<br/>

### **🔖정리**

<br/>

1. 적절한 자료형 = 아주 쉬운 문제 풀이
2. 문자열 처리는 아주 필요할 때나 효율성이 중요하지 않을 때만 사용하자.

<br/>
