# [15990] 1, 2, 3 더하기 5

<br/>

## **📝문제**

<br/>

정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 3가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 단, 같은 수를 두 번 이상 연속해서 사용하면 안 된다.

- 1+2+1
- 1+3
- 3+1

정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

<br/>

### **입력**

<br/>

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 100,000보다 작거나 같다.

<br/>

### **출력**

<br/>

각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다.

<br/>

### **예제입출력**

<br/>

<div style="column-count:2; ">
  <div>

**예제 입력1**

```
3
4
7
10
```

  </div>
  <div>

**예제 출력1**

```
3
9
27
```

  </div>
</div>

<br/>

### **출처**

<br/>

https://www.acmicpc.net/problem/15990

<br/>

## **🧐CODE REVIEW**
***

<br/>

### **🧾나의 풀이**

<br/>

```python
n = int(input())
numbers = [int(input()) for _ in range(n)]
max_num = max(numbers)
mod = 1000000009

DP = [[0, 0, 0, 0] for _ in range(max_num+1)]
DP[1] = [0, 1, 0, 0]
DP[2] = [0, 0, 1, 0]
DP[3] = [0, 1, 1, 1]

for i in range(4, max_num+1):
    DP[i][1] = (DP[i-1][2] + DP[i-1][3]) % mod
    DP[i][2] = (DP[i-2][1] + DP[i-2][3]) % mod
    DP[i][3] = (DP[i-3][1] + DP[i-3][2]) % mod

for num in numbers:
    print(sum(DP[num]) % mod)
```

<br/>

결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B)
:----:|:-----:|:-----:|:-----:|:--------:
맞았습니다!! |	52252 |	324 |	Python 3 | 	433

<br/>

#### **📝해설**

<br/>

매 경우를 마지막이 1인 경우, 2인 경우, 3인 경우로 나눠서 생각해보자.

경우를 나누어서 저장형태는 DP[n][1], DP[n][2], DP[n][3]에 각각 저장한다.

그러면 DP[N][1] 값은 마지막이 1이어야 하기 때문에 DP[N-1]의 경우에서 순서가 중복되지 않도록 마지막이 2와 3인 경우를 더하면 된다. 그러면 `DP[N][1] = DP[N-1][2] + DP[N-1][3]`이다.

같은 방법으로 `DP[N][2] = DP[N-2][1] + DP[N-2][3]`이고 `DP[N][3] = DP[N-3][1] + DP[N-3][2]`이다.

그런데 주의해야할 점은 매 경우를 계산할 때마다 `1,000,000,009`로 나눠주어야 시간초과가 나지 않을 수 있다.

<br/>

**점화식**
```
DP[N][1] = DP[N-1][2] + DP[N-1][3]
DP[N][2] = DP[N-2][1] + DP[N-2][3]
DP[N][3] = DP[N-3][1] + DP[N-3][2]
```

<br/>

### **다른 풀이**

<br/>

```python
import sys

D = [[1, 0, 0], [0, 1, 0], [1, 1, 1]]
for i in range(3, 100001):
    D.append([(D[-1][1]+D[-1][2])%1000000009, (D[-2][0]+D[-2][2])%1000000009, (D[-3][0]+D[-3][1])%1000000009])

for _ in range(int(sys.stdin.readline())):
    print(sum(D[int(sys.stdin.readline())-1])%1000000009)
```

<br/>

아이디 |	문제	| 문제 제목 |	결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B) 
:-----:|:-----:|:---------:|:-----:|:-----:|:-----:|:----:|:--------:
redpigeon |	15990 |	1, 2, 3 더하기 5 |	맞았습니다!! |	49596 |	172 |	Python 3 |	290

<br/>

#### **📝해설**

<br/>

한줄에 계산을 다 끝내버리는 숏코딩 시간도 빠른게 입력값중에 제일 큰 값까지만 값을 구하는 것보다 입력 제한 값까지 모두 계산하는게 훨씬 빠른 것 같다.

<br/>

### **🔖정리**

<br/>

1. 점화식을 구할 때 나올 수 있는 경우를 잘 나눠서 생각해 봐야한다. 해당 문제에서 n값 사이의 관계만 생각했을 때는 풀어낼 수 없다. n내부에서도 경우가 나누어 지는지를 생각해야하고 이것이 포인트다.

<br/>

## 📚참고 사이트

<br/>

- **[제목]**<br/>
사이트 주소