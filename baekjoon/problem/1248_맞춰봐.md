# [1248] 맞춰봐

## **📝문제**

규현이는 멍청하다. 왜냐하면, 1~10까지 수 밖에 모르기 때문이다. 어느 날 규현이 옆을 지나가던 태석이가 규현이를 보고 이렇게 외쳤다. "빵빵!!" 규현이는 "아하!" 하면서 세상에는 빵이란 수도 있구나 했다. 그날 이후로 규현이는 매일 친구들을 볼 때면 "빵빵!!" 거리면서 인사를 했다. 규현이의 친구 중에는 태방이가 있다. 자꾸 규현이가 "빵빵!!" 거릴때 마다 자신을 놀리는 것 처럼 생각했던 태방이는 규현이에게 그건 "빵이 아니고 영이야" 라고 가르쳐 줬다.

이제 규현이는 0~10까지 수를 알고 있다. 어느 날 자신이 알고 있는 숫자를 까먹지 않으려고 종이에 1~10까지 수를 썻다. (0은 잠시 까먹었다) 규현이의 친구 석원이는 밀덕이다. 계급을 엄청나게 좋아해서, 규현이가 써 놓은 숫자에 이등병 마크인 -를 모두 그렸다. 석원이는 규현이에게 이렇게 말했다. "너, 우리 위대하신 미하엘 칼라시니코프께서 뭐라고 했는지 알아? 단순함과 신뢰성, 그리고 저렴한 가격이 최고야!"

규현이는 그 말을 듣고서 아하 세상에는 음수도 있구나 했다.

이제 규현이가 아는 수는 -10부터 10까지 20개가 되었다. 아차, 0을 빼먹었구나, 21개가 되었다.

근처 사파리에 놀러간 규현이는 사파리 가이드 승환이와 함께 관광을 시작했다. "저기, 사자 1마리가 보이죠? 그 옆이 그 사자 부인이에요. 그러니깐, 1 더하기 1은 2죠" 규현이는 덧셈을 익혔다. "저 사자는 아까 그 사자의 자식 2마리 입니다. 그럼 총 사자는 몇 마리이지요?" 이제 규현이는 1+1을 제외한 다른 덧셈도 할 수 있다. 만세!

인도네시아에 놀러간 규현이는 자바 섬에 방문했다. 자바 섬에는 자바 커피를 재배하는 홍태석 농부가 있었다. 홍태석은 "ㅋㅋㅋ 님 음수와 양수와 0의 차이도 모름?" 하면서 음수와 양수와 0을 설명해주었다.

지금까지 배운 것을 종합해서, 한국으로 돌아오는 비행기에서 규현이는 종이에 수를 N개 썼다. (규현이가 아는 가장 큰 수는 10이기 때문에, 수를 10개까지만 쓸 수 있다.)  그 다음에, 가능한 모든 N*(N+1)/2개의 구간의 합을 구했다. 이 것을 해인이는 행렬로 표현했다.

규현이가 쓴 수를 A라고 하면, A[i]는 규현이가 i번째 쓴 수이다. 그리고, S[i][j]는 A[i]부터 A[j]까지 합이 0보다 크면 +, 0이면 0, 0보다 작으면 -이다. 여기서 i는 항상 j보다 작거나 같다. 이렇게 배열을 채우면 배열에는 총 N*(N+1)/2개의 문자가 있다. (+, -, 0 중 하나) 이 S 배열이 주어졌을 때, 규현이가 쓴 N개의 수 A를 구해서 출력하면 된다. 규현이는 -10부터 10까지의 정수밖에 모르기 때문에, A도 -10부터 10까지의 정수로만 이루어져 있어야 한다.

### **입력**

첫째 줄에 수열의 크기 N이 주어진다. N은 10보다 작거나 같은 자연수이다. 둘째 줄에는 N(N+1)/2 길이의 문자열이 주어진다. 처음 N개의 문자는 부호 배열의 첫 번째 줄에 해당하고, 다음 N-1개의 문자는 두 번째 줄에 해당한다. 마찬가지로 마지막 문자는 N번째 줄에 해당하는 문자다.

### **출력**

첫째 줄에 수열의 원소 N개를 빈 칸을 사이에 두고 출력한다. 답이 여러 가지 일 경우에는 아무거나 출력하면 된다.

### **예제입출력**

**예제 입력1**

```
4
-+0++++--+
```

**예제 출력1**

```
-2 5 -3 1
```

### **출처**

https://www.acmicpc.net/problem/1248

## **🧐CODE REVIEW**

### **😫나의 오답 풀이**
### **🧾나의 풀이**

```python
def check(idx):
    total = 0
    for i in range(idx, -1, -1):
        total += result[i]
        if total == 0 and S[i][idx] != 0:
            return False
        elif total < 0 and S[i][idx] >= 0:
            return False
        elif total > 0 and S[i][idx] <= 0:
            return False
    return True


def dfs(idx):
    if idx == n:
        return True
    if S[idx][idx] == 0:
        result[idx] = 0
        return dfs(idx+1)
    for i in range(1, 11):
        result[idx] = S[idx][idx] * i
        if check(idx) and dfs(idx+1):
            return True
    return False


n = int(input())
s = list(input())
S = [[0] * n for _ in range(n)]
result = [0] * n

for i in range(n):
    for j in range(i, n):
        if s[0] == 0:
            S[i][j] = 0
        elif s[0] == '+':
            S[i][j] = 1
        elif s[0] == '-':
            S[i][j] = -1
        s.pop(0)

dfs(0)

print(' '.join(map(str, result)))
```

|     결과     | 메모리(KB) | 시간(ms) |   언어   | 코드 길이(B) |
| :----------: | :--------: | :------: | :------: | :----------: |
| 맞았습니다!! |   30864    |   6524   | Python 3 |     920      |

#### **📝해설**

**알고리즘**

사족이 너무 긴 문제이다. 굳이 필요없는 내용을 재밌게 해본다고 넣어놓은 것 같은데 이해가 더 안됐다. 뒤에 내용만 읽어보면 된다.

> 규현이가 쓴 수를 A라고 하면, A[i]는 규현이가 i번째 쓴 수이다. 그리고, S[i][j]는 A[i]부터 A[j]까지 합이 0보다 크면 +, 0이면 0, 0보다 작으면 -이다. 여기서 i는 항상 j보다 작거나 같다.

```
4
-+0++++--+
```

입력 예제에서 입력받은 +-0들의 구조가 다음 배열의 형태라는 이야기이다. 

S[i][j]에서 i는 항상 j보다 작거나 같기때문에 큰 경우를 제외해서 다음과 같은 구조가 나온다.

|   -   |   0   |   1   |   2   |   3   |
| :---: | :---: | :---: | :---: | :---: |
|   0   |   -   |   +   |   0   |   +   |
|   1   |       |   +   |   +   |   +   |
|   2   |       |       |   -   |   -   |
|   3   |       |       |       |   +   |


```
1. 입력받은 부호와 0을 S[i][j]형태의 배열로 변환
2. 대각선 부분(i==j)이 0이면 0
3. 대각선 부분(i==j)이 +이면 1부터 10, -이면 -1부터 -10까지
3-1. 숫자들이 각 자리에 들어갈 때 S 배열의 조건에 맞는지 확인
4. index가 입력받은 n의 값과 같아지면 종료
```

대충 문제의 흐름은 이해가 된다. 그런데 구현 부분이 생각보다 까다로워서 거의 모든 부분을 블로그 글에서 참고했다. 블로그 주소는 하단에 남겨두었다.

까다로웠던 부분을 써보자면, 답이 될 수를 이어나가다가 조건에서 걸러지면서 중단시키고 조건에 맞는다면 계속 이어나가는 것이 dfs의 기본적인 원리인데, 이 문제는 dfs에 이어나가는 수를 인자로 줘야하는지 주지 않아야하는지 판단이 잘 안섰다.

주지 않는다면 위의 답처럼 나오게 되는데 인자로 주고 풀이를 이어나간다면 답이 될 수 있는 모든 답을 구하게 된다. 문제에 맞지않는 비효율적인 작업을 하는 것이다. 그래서 인자를 주지 않고 답이 되는 배열 하나만 이용해서 풀이를 해야하는 것이 적합한 방법이 맞다.

그런데 그렇게 된다면 앞에서 맞다고 판단한 답이 뒤에서 모든 경우가 조건에 맞지 않는 경우가 나오게 된다면 틀릴 수도 있지 않은가? 그리고 인자를 주지 않고 어떤 방법으로 풀어내야하지? 혼자 생각만 엄청하다가 똥꼬쇼한 문제이다.

정리하면 그냥 생각만 많이 하다가 똥꼬쇼하고 gg치고 해답봤다는 얘기다.

boolean값을 return하는 dfs방식을 처음 봤다. 이렇게도 할 수 있구나 싶었던 문제.

### **🔖정리**

1. boolean을 return하는 새로운 dfs 방식을 배웠다.
2. 한번 생각을 정리하고 풀이를 할 필요가 있어보인다.

## 📚참고 사이트

> **[개발냥발 블로그]**<br/>
> https://hazung.tistory.com/127<br/>
> 여기 글이 이해하기 쉽게 잘써져 있다.
