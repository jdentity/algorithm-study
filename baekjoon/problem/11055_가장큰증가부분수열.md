# [11055] 가장 큰 증가 부분 수열

<br/>

## **📝문제**

<br/>

수열 A가 주어졌을 때, 그 수열의 증가 부분 수열 중에서 합이 가장 큰 것을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 인 경우에 합이 가장 큰 증가 부분 수열은 A = {**1**, 100, **2**, **50**, **60**, 3, 5, 6, 7, 8} 이고, 합은 113이다.

<br/>

### **입력**

<br/>

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)

<br/>

### **출력**

<br/>

첫째 줄에 수열 A의 합이 가장 큰 증가 부분 수열의 합을 출력한다.

<br/>

### **예제입출력**

<br/>

<div style="column-count:2; ">
  <div>

**예제 입력1**

```
10
1 100 2 50 60 3 5 6 7 8
```

  </div>
  <div>

**예제 출력1**

```
113
```

  </div>
</div>

<br/>

### **출처**

<br/>

https://www.acmicpc.net/problem/11055

<br/>

## **🧐CODE REVIEW**
***

<br/>

### **😫나의 오답 풀이**
### **🧾나의 풀이**

<br/>

```python
import sys

n = int(input())
seq = list(map(int, sys.stdin.readline().rstrip().split()))
dp = [0] * (n)
dp[0] = seq[0]

for i in range(1, n):
    dp[i] = max([0] + [dp[j] for j in range(i) if seq[i] > seq[j]]) + seq[i]
print(max(dp))
```

<br/>

결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B)
:----:|:-----:|:-----:|:-----:|:--------:
맞았습니다!! |	29200 |	144 |	Python 3 |	234

<br/>

#### **📝해설**

<br/>

dp[n]을 n번째 숫자를 마지막으로 뽑았을 때의 수열 중 제일 큰 값으로 생각하고 풀면 금방 풀 수 있다. 다만 시간복잡도가 O(N^2)에 가까워서 가장 효율적인 방법은 아닐 것으로 생각한다.

풀이를 보면 조건문으로 골라서 list를 만들어서 max함수를 사용하는데 내부에 아무것도 들어있지 않은 상태를 예외처리해주어야한다. 그래서 0을 추가로 집어넣은 것이다.

<br/>

### **다른 풀이**

<br/>

```python
n = int(input())
a = list(map(int, input().split()))
c = [0] * 1001
for i in range(n): c[a[i]] = max(c[:a[i]]) + a[i]
print(max(c))
```

<br/>

아이디 |	문제	| 문제 제목 |	결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B) 
:-----:|:-----:|:---------:|:-----:|:-----:|:-----:|:----:|:--------:
rkaxhdals |	11055 |	가장 큰 증가 부분 수열 |	맞았습니다!! |	29284 |	60 |	Python 3 |	131

<br/>

#### **📝해설**

<br/>

아이디어가 진짜 대단한 풀이 방식이다. 값들을 인덱스 삼아서 나열해두고 그 값을 기준으로 슬라이싱하면 큰지 작은지 조건문을 사용하지 않아도 된다.

<br/>