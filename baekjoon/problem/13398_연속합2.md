# [13398] 연속합 2

<br/>

## **📝문제**

<br/>

n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다. 또, 수열에서 수를 하나 제거할 수 있다. (제거하지 않아도 된다)

예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 수를 제거하지 않았을 때의 정답은 12+21인 33이 정답이 된다.

만약, -35를 제거한다면, 수열은 10, -4, 3, 1, 5, 6, 12, 21, -1이 되고, 여기서 정답은 10-4+3+1+5+6+12+21인 54가 된다.

<br/>

### **입력**

<br/>

첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.

<br/>

### **출력**

<br/>

첫째 줄에 답을 출력한다.

<br/>

### **예제입출력**

<br/>

<div style="column-count:2; ">
  <div>

**예제 입력1**

```
10
10 -4 3 1 5 6 -35 12 21 -1
```

  </div>
  <div>

**예제 출력1**

```
54
```

  </div>
</div>

<br/>

### **출처**

<br/>

https://www.acmicpc.net/problem/13398

<br/>

## **🧐CODE REVIEW**
***

<br/>

### **🧾나의 풀이**

<br/>

```python
from sys import stdin, maxsize

n = int(input())
seq = list(map(int, stdin.readline().rstrip().split()))
dp = [[0, 0] for _ in range(n)]
dp[0] = [seq[0], -maxsize]

for i in range(1, n):
    dp[i][0] = max(dp[i-1][0] + seq[i], seq[i])
    dp[i][1] = max(dp[i-1][0], dp[i-1][1] + seq[i])

answer = -maxsize
for i in range(n):
    answer = max(answer, max(dp[i]))

print(answer)
```

<br/>

결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B)
:----:|:-----:|:-----:|:-----:|:--------:
맞았습니다!! |	40988 |	280 |	Python 3 |	376

<br/>

#### **📝해설**

<br/>

이 문제도 삽질을 정말 많이 했는데 그냥 숫자하나를 제외한 경우와 제외하지 않은 경우 두가지로 나누면 정말 쉽다.

하... 왜 이 생각을 못했지... 결국 구글링해서 알아냈다.😭

<br/>

숫자 배열에서 N번째 숫자를 마지막으로 집었을 때 숫자를 하나도 제외하지 않은 경우를 DP[N][0], 숫자 하나를 제외한 경우를 DP[N][1]이라고 하자. 그렇다면 점화식은 쉽게 나온다.

**점화식**
```
DP[N][0] = MAX(DP[N-1][0] + NUM[N], NUM[N])
DP[N][1] = MAX(DP[N-1][0], DP[N-1][1] + NUM[N])
```

<br/>

DP의 전체에서 제일 큰 숫자만 찾으면 해결!

<br/>

### **다른 풀이**

<br/>

```python
import sys

N = int(input())

nums = list(map(int, sys.stdin.readline().strip().split()))

cur = [0] * N
maxCur = [0] * N

for i, num in enumerate(nums):
    cur[i] = max(cur[max(i-1, 0)] + num, num)
    
    if num >= 0:
        maxCur[i] = max(maxCur[max(i-1, 0)] + num, cur[i])
        
    else:
        maxCur[i] = max(cur[max(i-1,0)], num, maxCur[i-1] + num)

print(max(maxCur))
```

<br/>

아이디 |	문제	| 문제 제목 |	결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B) 
:-----:|:-----:|:---------:|:-----:|:-----:|:-----:|:----:|:--------:
suskin25 |	13398 |	연속합 2 |	맞았습니다!! |	135192 |	128	| PyPy3 |	385

<br/>

#### **📝해설**

<br/>

DP list를 2차원으로 두지 않고 list를 두개 사용해서 해결했다.

또한 숫자를 제외하는 경우는 숫자가 음수일 경우이기 때문에 조건문을 두어서 음수인 부분과 아닌 부분을 나누어 처리해서 조금 더 효율적인 코드이다.

<br/>

### **🔖정리**

<br/>

1. 어려우면서도 쉬운 dp의 세계...

<br/>

## 📚참고 사이트

<br/>

- **[백준 13398 파이썬 python : 연속합 2 @@황소처럼 우직하게@@ 쉬버..]**<br/>
https://hjp845.tistory.com/122<br/>
황소개발자님도 욕을 하셨다...