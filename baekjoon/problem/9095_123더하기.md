# [9095] 1, 2, 3 더하기

## **📝문제**

정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.

- 1+1+1+1
- 1+1+2
- 1+2+1
- 2+1+1
- 2+2
- 1+3
- 3+1

정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

### **입력**

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.

### **출력**

각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.

### **예제입출력**

**예제 입력1**

```
3
4
7
10
```

**예제 출력1**

```
7
44
274
```

### **출처**

https://www.acmicpc.net/problem/9095

## **🧐CODE REVIEW**

### **🧾나의 풀이**

```python
def dfs(target_num, add_num, value):
    global case
    value = value + add_num
    if value == target_num:
        case += 1
    if value > target_num:
        return
    dfs(target_num, 1, value)
    dfs(target_num, 2, value)
    dfs(target_num, 3, value)

result = []
n = int(input())
nums = [int(input()) for _ in range(n)]

for i in range(n):
    case = 0
    dfs(nums[i], 0, 0)
    result.append(case)

print("\n".join(map(str, result)))
```

결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B)
:----:|:-----:|:-----:|:-----:|:--------:
맞았습니다!! |	30860 |	68 |	Python 3 |	444

#### **📝해설**

**알고리즘**
```
DFS를 이용한다.(HOW?)
1. 하나의 경우에서 세 개씩의 분기(1,2,3)를 만들어나가면 된다.
2. 조건을 만족한 경우 값을 +1해주고 해당 분기는 종료
3. 조건을 만족하지 못한 경우 해당 분기는 종료
```

### **다른 풀이**

```python
N = int(input())
arr=[1,2,4]
for i in range(4,11):
    arr.append(sum(arr[-3:]))
for _ in range(N):
    T = int(input())
    print(arr[T-1])
```

아이디 |	문제	| 문제 제목 |	결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B) 
:-----:|:-----:|:---------:|:-----:|:-----:|:-----:|:----:|:--------:
cho6206 |	9095 |	1, 2, 3 더하기 |	맞았습니다!! |	29284 |	52 |	Python 3 |	141

#### **📝해설**

문제의 규칙을 찾아서 가장 빠르고 짧은 코드로 해결할 수 있었던 방법이다.

```python
for i in range(4,11):
    arr.append(sum(arr[-3:]))
```

이 부분이 문제의 규칙을 볼 수 있는 부분인데arr의 진행을 보면 다음과 같다.

```
[1, 2, 4, 7]
[1, 2, 4, 7, 13]
[1, 2, 4, 7, 13, 24]
[1, 2, 4, 7, 13, 24, 44]
[1, 2, 4, 7, 13, 24, 44, 81]
[1, 2, 4, 7, 13, 24, 44, 81, 149]
[1, 2, 4, 7, 13, 24, 44, 81, 149, 274]
...
```

끝 부분 세개씩 계속해서 더해나가면 된다.

다음과 같은 규칙을 찾을 수 있었던 방법은 DP 방식을 참고하면 된다.

```
DP[N] = DP[N-1] + DP[N-2] + DP[N-3]
```
다음의 규칙을 만족했기 때문에 이런 풀이가 가능했다.

### **🔖정리**

1. 오랜 기억속에 낡아가던 DP를 다시 기억했다.