# [11053] 가장 긴 증가하는 부분 수열

<br/>

## **📝문제**

<br/>

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.

<br/>

### **입력**

<br/>

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)

<br/>

### **출력**

<br/>

첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

<br/>

### **예제입출력**

<br/>

<div style="column-count:2; ">
  <div>

**예제 입력1**

```
6
10 20 10 30 20 50
```

  </div>
  <div>

**예제 출력1**

```
4
```

  </div>
</div>

<br/>

### **출처**

<br/>

https://www.acmicpc.net/problem/11053

<br/>

## **🧐CODE REVIEW**
***

<br/>

### **🧾나의 풀이**

<br/>

```python
import sys

n = int(input())
seq = list(map(int, sys.stdin.readline().rstrip().split()))
dp = [1] * n

for i in range(n):
    for j in range(i):
        if seq[j] < seq[i] and dp[j] >= dp[i]:
            dp[i] = dp[j] + 1

print(max(dp))
```

<br/>

결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B)
:----:|:-----:|:-----:|:-----:|:--------:
맞았습니다!! |	29200	| 172 |	Python 3 |	238

<br/>

#### **📝해설**

<br/>

DP의 대표격인 문제 LIS이다.

dp[i]를 index i가 마지막에 오는 수열 중 가장 긴 증가하는 수열의 길이라고 하자. 가장 긴 증가하는 수열은 너무 길기 때문에 줄여서 LIS(Longest Increasing Subsequence)라고 하자.

<br/>

```
DP[1] = 1  [10]
DP[2] = 2  [10, 20]
DP[3] = 1  [10]
DP[4] = 3  [10, 20, 30]
DP[5] = 2  [10, 20]
DP[6] = 4  [10, 20, 30, 50]
MAX(DP) = 4
```

<br/>

이런 방법으로 구해나가면 된다. 뭔가 확 점프한 것 같은 기분이 들 수도 있다. 내부 프로세스를 더 자세히 살펴보자.

<br/>

**DP[1] = 1  [10]**

DP[1]은 앞에 다른 수가 더 없으니 하나만 집을 수 있다. 그래서 1이다.

**DP[2] = 2  [10, 20]**

DP[2]는 앞에 1을 살펴볼 수 있다. index 1의 값이 20보다 작은 10이니까 `DP[2] = DP[1] + 1`이 가능하다.

**DP[3] = 1  [10]**

수열의 세번째 숫자 10은 앞에 다른 숫자들보다 크지 않다. 앞에 붙일 수 있는 숫자가 없기 때문에 `DP[3] = 1`이다.

**DP[4] = 3  [10, 20, 30]**

DP[4]는 DP[1]부터 DP[3]까지 살펴볼 수 있다. 4번째 숫자는 30인데 수열중에 2번째 오는 숫자가 20으로 30보다 작기 때문에 앞에 붙일 수 있는 숫자이다. DP[2]는 앞에 올 수 있는 DP중에 가장 큰 값이기 때문에 `DP[4] = DP[2] + 1`이며 값은 3이다.

**DP[5] = 2  [10, 20]**

같은 방법으로 살펴보면 `DP[5] = DP[3] + 1` 이나 `DP[5] = DP[1] + 1`이 될 수 있다.

**DP[6] = 4  [10, 20, 30, 50]**

같은 방법으로 6번째 숫자인 50보다 작고 가장 큰 DP값을 가진 index는 4이다. 그러므로 `DP[6] = DP[4] + 1` 이다.

<br/>

DP를 연산해가는 과정 중 조건을 정리하면 두 가지이다.

1. 현재 index의 숫자 앞에 붙일 수 있는 수인지
2. 앞에 붙일 수 있는 수열 중 가장 긴 수열인지 (DP값이 가장 큰지)

<br/>

처음에 설명을 봤을 때 너무 이해가 안가서 여러번 보고 직접 해보고 이해한 내용을 정리해봤다.

<br/>

#### **😅개선점**

<br/>

1. **시간복잡도 O(n^2)**

시간복잡도가 이중루프를 돌리기 때문에 비효율적이다. 그래서 시간 복잡도를 개선해야하는데 2탄문제가 입력값을 훨씬 많이 받기 때문에 시간복잡도를 개선해야만 해결할 수 있는 문제이다. 개선은 2번문제에서 해보도록 하자.

[가장긴증가하는부분수열2](.problem/12015_가장긴증가하는부분수열2.md)

<br/>

### **🔖정리**

<br/>

1. LIS에 대해서 배웠다. DP접근 방법이 아직 더 연습이 필요해보인다.

<br/>

## 📚참고 사이트

<br/>

- **[최장 증가 부분 수열 (by 나무위키)]**<br/>
https://namu.wiki/w/%EC%B5%9C%EC%9E%A5%20%EC%A6%9D%EA%B0%80%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4<br/>
꺼무위키에서 설명을 제일 잘 해놓았다. DP접근법 문제 중에 가장 유명한 문제 중에 하나라고 하니 설명을 쭉 읽어보는게 좋다. 그런데 나는 한두번 읽어서는 이해가 잘 안됐다...

- **[가장 긴 증가하는 부분 수열 (Longest Increasing Subsequence)
(Seungkwan's Lab)]** <br/>
https://seungkwan.tistory.com/8