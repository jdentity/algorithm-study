# [2225] 합 분해

<br/>

## **📝문제**

<br/>

0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.

덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.

<br/>

### **입력**

<br/>

첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.

<br/>

### **출력**

<br/>

첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.

<br/>

### **예제입출력**

<br/>

<div style="column-count:2; ">
  <div>

**예제 입력1**

```
20 2
```

  </div>
  <div>

**예제 출력1**

```
21
```

  </div>
</div>

<br/>

### **출처**

<br/>

https://www.acmicpc.net/problem/2225

<br/>

## **🧐CODE REVIEW**
***

<br/>

### **🧾나의 풀이**

<br/>

```python
import sys

n, k = list(map(int, sys.stdin.readline().rstrip().split()))
mod = 1000000000
dp = [[0] * (n+1) for i in range(k+1)]
dp[0][0] = 1

for i in range(n+1):
    for j in range(1, k+1):
        dp[j][i] = sum(dp[j-1][:i+1]) % mod

print(dp[k][n] % mod)
```

<br/>

결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B)
:----:|:-----:|:-----:|:-----:|:--------:
맞았습니다!! |	30476 |	140 |	Python 3 |	259

<br/>

#### **📝해설**

<br/>

처음에는 접근 방법을 전혀 생각해낼 수가 없었다. 그래서 어쩔 수 없이 구글링을...😅

두가지 변수 N과 K에 따라서 답이 달라 질 수 있기 때문에 두가지 모두를 고려해야한다. 그래서 지금까지 DP[N]으로 접근했던 것과는 다르게 `DP[N][K]`라는 방식으로 접근해나가야한다. DP[N][K]에 어떤 규칙성이 있는지 살펴보자.

<br/>

N\K| 0 | 1 | 2 | 3 | 4 
:-:|:-:|:-:|:-:|:-:|:-:
 **0** | 0 | 1 | 1 | 1 | 1 
 **1** | 0 | 1 | 2 | 3 | 4 
 **2** | 0 | 1 | 3 | 6 | 10 
 **3** | 0 | 1 | 4 | 10 | 20 
 **4** | 0 | 1 | 5 | 15 | 35 

<br/>

```
DP[2][3] => 020 200 110 101 011 002
```

DP[2][3]안에서 끝자리수만 떼어내서 보자.

```
DP[2][3] => 02_ 20_ 11_ 10_ 01_ 00_
```

이 수열들을 DP로 표현해보자. 그러면 반대로도 생각해 볼 수 있다.

```
02 20 11 = DP[2][2] 
=> N이 같은 값이니 자리수 하나만 채워주면 됨 끝자리에 0을 붙임
020 200 110

10 01 = DP[1][2] 
=> N-1이니 끝자리에 1을 붙임
101 011

00 = DP[1][2] 
=> N-2이니 끝자리에 2를 붙임
002
```

그러면 DP[2][3] = DP[2][2] + DP[1][2] + DP[0][2]를 만족한다.

이제 점화식을 구해볼 수 있다.

<br/>

**점화식**
$$ DP[N][K] = \sum_{i=0}^{N} DP[N-i][K-1] $$

<br/>

다른 분들은 인덱스를 `DP[N][K]`순으로 정렬한 것을 봤는데 나는 역순으로 뒤집어서 `DP[K][N]`으로 풀이했다. 그 이유는 그냥 단순한 문제인데,

```python
for i in range(n+1):
    for j in range(1, k+1):
        dp[j][i] = sum(dp[j-1][:i+1]) % mod
```

사실 반복하는 횟수에 있어서는 차이가 없지만, for문을 하나 덜 쓰고 싶어서 sum과 list slicing을 사용해서 풀이했다. 뒤집은 형태가 아니라면 list slicing을 사용할 수 없다. 이중리스트에서는 첫번째 인덱스에서 list slicing을 사용하면 index error가 나기 때문이다. list slicing이 필요한 인덱스를 두번째위치로 바꿨다 정도로만 알아주시면 되겠다.

<br/>

#### **😅개선점**

<br/>

1. **시간복잡도 O(N^3)**

위에서 사용한 풀이의 시간복잡도는 정확히 말하면 `O(KN^2)`이다. 통과는 했지만 좋은 풀이는 아니다.

<br/>

$$ DP[N][K] = \sum_{i=0}^{N-1} DP[N-i][K-1] + DP[N][K-1] $$
$$ DP[N-1][K] = \sum_{i=0}^{N-1} DP[N-i][K-1] $$
$$ DP[N][K] = DP[N-1][K] + DP[N][K-1] $$

<br/>

간단한 **치환**으로 위와 같은 식이 성립한다.

<br/>

**점화식**
$$ DP[N][K] = DP[N-1][K] + DP[N][K+1] $$

<br/>

훨씬 더 효율적인 점화식이 도출되었다. 시간복잡도는 O(KN) => O(N^2)에 수렴할 수 있다. loop문을 하나 없앨 수 있겠다. 코드로 다시 작성해보자.

<br/>

```python
import sys

n, k = list(map(int, sys.stdin.readline().rstrip().split()))
mod = 1000000000
dp = [[0] * (k+1) for _ in range(n+1)]
dp[0][0] = 1

for i in range(0, n+1):
    for j in range(1, k+1):
        dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % mod

print(dp[n][k] % mod)
```

<br/>

결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B)
:----:|:-----:|:-----:|:-----:|:--------:
맞았습니다!! |	30476	| 88 |	Python 3 |	268

<br/>

### **다른 풀이**

<br/>

```python
def fac(n):
    sum =1
    for _ in range(1, n+1):
        sum *= _
    return sum

n, r = map(int, input().split())
print(fac(n+r-1)//(fac(r-1)*fac(n))%1000000000)
```

<br/>

아이디 |	문제	| 문제 제목 |	결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B) 
:-----:|:-----:|:---------:|:-----:|:-----:|:-----:|:----:|:--------:
sdhqaz |	2225 |	합분해 |	맞았습니다!! |	29056 |	56 |	Python 3 |	164

<br/>

#### **📝해설**

<br/>

DP로 풀지 않고 계산법을 찾아내서 풀었다. 팩토리얼 부분의 연산만 필요하기 때문에 효율이 엄청나게 올라갔다. 풀이에 의하면 N과 K에 대해서 다음 식을 만족한다.

$$ \frac{(N+K-1)!}{(K-1)!(N)!} $$

<br/>

### **🔖정리**

<br/>

1. 두개의 변수를 가지고 있는 DP를 배웠다.

<br/>

## 📚참고 사이트

<br/>

- **[[백준] 2252 합분해 (by 개발자 안드선생)]**<br/>
https://hongcoding.tistory.com/49<br/>
설명은 여기서 제일 이해가 쉽게 해놓았다. 내 설명도 거의 이 글의 접근방식을 그대로 따른다.