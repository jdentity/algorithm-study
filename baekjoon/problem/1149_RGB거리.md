# [1149] RGB거리

<br/>

## **📝문제**

<br/>

RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.

집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

1번 집의 색은 2번 집의 색과 같지 않아야 한다.
N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

<br/>

### **입력**

<br/>

첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.

<br/>

### **출력**

<br/>

첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.

<br/>

### **예제입출력**

<br/>

<div style="column-count:2; ">
  <div>

**예제 입력1**

```
3
26 40 83
49 60 57
13 89 99
```

  </div>
  <div>

**예제 출력1**

```
96
```

<br/>
<br/>

  </div>
</div>

<br/>

### **출처**

<br/>

https://www.acmicpc.net/problem/1149

<br/>

## **🧐CODE REVIEW**
***

<br/>

### **🧾나의 풀이**

<br/>

```python
import sys

houses = int(input())
dp = [list(map(int, sys.stdin.readline().rstrip().split()))
      for _ in range(houses)]

for i in range(1, houses):
    dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + dp[i][0]
    dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + dp[i][1]
    dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + dp[i][2]

print(min(dp[houses-1]))
```

<br/>

결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B)
:----:|:-----:|:-----:|:-----:|:--------:
맞았습니다!! |	29452 |	80 |	Python 3 |	340

<br/>

#### **📝해설**

<br/>

DP는 매번 같은 접근 방식이라고는 하는데 할 때마다 새롭다...😭

N번의 차례 모두 각각 RGB 하나씩 선택하고 각각의 최저비용을 구해서 그 최저비용들중에 가장 작은 것을 선택하면 된다. 결국 다 확인해본다고 보면 된다. 막상 써보니까 쉬운데 생각해내기는 쉽지가 않았다.

0을 R, 1을 G, 2를 B라고 보면 된다.

<br/>

**점화식**
```
# R 선택 다음 G,B중에 작은 것 선택
DP[N][0] = min(DP[N-1][1], DP[N-1][2]) + RGB[N][0] 
# G 선택 다음 R,B중에 작은 것 선택
DP[N][1] = min(DP[N-1][0], DP[N-1][2]) + RGB[N][1]
# B 선택 다음 R,G중에 작은 것 선택
DP[N][2] = min(DP[N-1][0], DP[N-1][1]) + RGB[N][2]
```

<br/>

```python
for i in range(1, houses):
    dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + dp[i][0]
    dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + dp[i][1]
    dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + dp[i][2]
```

<br/>

나는 그냥 받은 list에다가 연산을 진행했다. 사실 list를 하나 더 만드나 안만드나 상관 없다.

<br/>

### **다른 풀이**

<br/>

```python
def solution():
    import sys
    R,G,B = 0, 0, 0
    for i in range(int(sys.stdin.readline())):
        r, g, b = map(int, sys.stdin.readline().rstrip().split())
        r += min(G, B)
        g += min(R, B)
        b += min(R, G)
        R,G,B = r,g,b
    print(min(R,G,B))
        
solution()
```

<br/>

아이디 |	문제	| 문제 제목 |	결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B) 
:-----:|:-----:|:---------:|:-----:|:-----:|:-----:|:----:|:--------:
whilescape |	1149 |	RGB거리 |	맞았습니다!! |	29056 |	56 |	Python 3 |	296

<br/>

#### **📝해설**

<br/>

효율성, 가독성, 숏코드 세마리 토끼를 다 잡아버린 풀이... 그저 빛✨

<br/>

1. 저장할 거 없이 바로 값 받아서 사용함.

```python
    for i in range(int(sys.stdin.readline())):
        r, g, b = map(int, sys.stdin.readline().rstrip().split())
```

집이 몇개야? n에 받아줘 그리고 n만큼 for문 돌려줘 뭐 이럴 필요도 없이 그냥 for문에다가 박아 버렸다. rgb 비용값도 그냥 매번 받을 때마다 연산을 진행하도록 했다.

<br/>

2. 

```python
R,G,B = 0, 0, 0
...
        r += min(G, B)
        g += min(R, B)
        b += min(R, G)
        R,G,B = r,g,b
```

DP[N][0], DP[N][1], DP[N][2] 0은 R인거고 1은 G인거고 2는 B인거야! 뭐 이럴 필요도 없이 그냥 R, G, B 변수로 받아서 해결했다. 매번 결과를 하나하나 저장할 필요없이 더해나가면 된다는 거다. 이러면 LIST의 index도 생각할 필요없다.

가독성이 확 살아나는 것 뿐만 아니라 `dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + dp[i][0]` 이랬던 거랑 비교하면 훨씬 짧다.

<br/>

### **🔖정리**


<br/>

1. 다이나믹 프로그래밍은 차례로 모든 경우를 따져보고 답에 맞는 것을 골라나가는 것이다. 이것을 잊지 말자. 어떻게 하면 효율적으로 모든 경우를 따져볼 수 있을지 생각해보자.

<br/>

## 📚참고 사이트

<br/>

- **[코딩과 디버깅 사이 네이버 블로그]**<br/>
https://m.blog.naver.com/occidere/220785383050<br/>
진짜 자세하고 쉽게 설명해놓으셨다. 네이버 블로그에 이런 글이 있을 줄이야... 접근 방법은 이 블로그를 참고했다. 진짜 강추한다.
