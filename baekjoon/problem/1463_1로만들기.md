# [1463] 1로 만들기

<br/>

## **📝문제**

<br/>

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

<br/>

### **입력**

<br/>

첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

<br/>

### **출력**

<br/>

첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

<br/>

### **예제입출력**

<br/>

<div style="column-count:2; ">
  <div>

**예제 입력1**

```
2
```

  </div>
  <div>

**예제 출력1**

```
1
```

  </div>
</div>

<br/>

<div style="column-count:2; ">
  <div>

**예제 입력2**

```
10
```

  </div>
  <div>

**예제 출력2**

```
3
```

  </div>
</div>

<br/>

### **힌트**

<br/>

10의 경우에 10 -> 9 -> 3 -> 1 로 3번 만에 만들 수 있다.

<br/>

### **출처**

<br/>

https://www.acmicpc.net/problem/1463

<br/>

## **🧐CODE REVIEW**
***

<br/>

### **😫나의 오답 풀이**

<br/>

```python
num = int(input())
n = 1
count = 0

while num > n:
    if n * 3 <= num:
        n *= 3
    elif n * 2 <= num:
        n *= 2
    elif n + 1 <= num:
        n += 1
    count += 1

print(count)
```

<br/>

결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B)
:----:|:-----:|:-----:|:-----:|:--------:
틀렸습니다 | | |			Python 3 |	192
<br/>

#### **📝해설**

<br/>

위에서부터 if문 만으로 그리디하게 풀면 10에서 틀린 답이 나오는데
아래에서부터 if문 만으로 그리디하게 풀면 맞는 답이 나오지 않을까 싶어서 한번 풀어봤다. 역시 다이나믹프로그래밍 접근 방식으로 문제를 풀지 않으면 반례가 존재한다.

<br/>

#### **😅개선점**

<br/>

1. 다이나믹 프로그래밍을 사용하지 않음.

그리디하게 푸는 것이 항상 최선의 답을 내지 않기 때문에 다이나믹 프로그래밍이 필요하다.

<br/>

```python
num = int(input())
DP = [0] * (num+1)

for i in range(2, num+1):
    DP[i] = DP[i-1] + 1
    if i % 3 == 0:
        DP[i] = min(DP[i], DP[i//3]+1)
    if i % 2 == 0:
        DP[i] = min(DP[i], DP[i//2]+1)

print(DP[num])
```

<br/>

결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B)
:----:|:-----:|:-----:|:-----:|:--------:
맞았습니다!! |	37012 |	672 |	Python 3 |	221

<br/>

밑에서부터 모든 숫자마다 최선의 케이스를 구하면서 해당 숫자까지 도달하면 그게 최선의 경우일 것이다. 말이 좀 어려운데 숫자를 하나씩 증가시키면서 각 케이스마다 최선의 케이스를 구한다고 생각하면 된다.

<br/>

### **다른 풀이**

<br/>

```python
save = {1:0, 2:1}
def frog(n):
    if n in save:
        return save[n]
    m = 1+min(frog(n//2)+n%2, frog(n//3)+n%3)
    save[n] = m
    return m

n = int(input())
print(frog(n))
```

<br/>

아이디 |	문제	| 문제 제목 |	결과	| 메모리(KB) |	시간(ms) |	언어 |	코드 길이(B) 
:-----:|:-----:|:---------:|:-----:|:-----:|:-----:|:----:|:--------:
dhkang184 |	1463 |	1로 만들기 |	맞았습니다!! |	29076 |	60 |	Python 3 |	179

<br/>

#### **📝해설**

<br/>

재귀적으로 해결했는데 효율적이고 깔끔하다.

```python
m = 1+min(frog(n//2)+n%2, frog(n//3)+n%3)
```

이 부분에서 횟수 1을 더하고 min함수 내부 인자에 2와 3으로 나누어 떨어지지 않는 경우까지 %로 나머지를 더해서 횟수처리해주는 부분이 인상적이다.

아직까지 다이나믹 프로그래밍 접근법이 익숙하지는 않다. 더 코드를 많이보고 연습해봐야 겠다.

<br/>

### **🔖정리**

<br/>

1. 다이나믹 프로그래밍

<br/>

## 📚참고 사이트

<br/>

- **[백준 1463번 : 1로 만들기(by 유셩쟝)]**<br/>
https://sihyungyou.github.io/baekjoon-1463/

- **[동적프로그래밍이란? (by 배움이 즐거운 개발자)]**<br/>
https://galid1.tistory.com/507

- **[[알고리즘] 동적 계획법(Dynamic Programming) - 1(by dev_nunu)]**<br/>
https://new93helloworld.tistory.com/220

- **[[알고리즘] 동적 계획법(Dynamic Programming) - 2(by dev_nunu)]**<br/>
https://new93helloworld.tistory.com/221?category=691027

- **[[알고리즘] 동적 계획법(Dynamic Programming) - 3(by dev_nunu)]**<br/>
https://new93helloworld.tistory.com/223?category=691027

<br/>

다이나믹 프로그래밍에 대한 좋은 자료가 정말 많다.