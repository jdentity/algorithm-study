# [2667] 단지 번호 붙이기

## **📝문제**

<그림 1>과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. <그림 2>는 <그림 1>을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.

![img](https://www.acmicpc.net/upload/images/ITVH9w1Gf6eCRdThfkegBUSOKd.png)

### **입력**

첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.

### **출력**

첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.

### **예제입출력**

**예제 입력1**

```
7
0110100
0110101
1110101
0000111
0100000
0111110
0111000
```

**예제 출력1**

```
3
7
8
9
```

### **출처**

acmicpc.net/problem/2667

## **🧐CODE REVIEW**

### **🧾나의 풀이**

```python
def dfs(x, y, cnt):
    global result
    dx = [1, -1, 0, 0]
    dy = [0, 0, 1, -1]
    for i in range(4):
        # list index 참조 조건
        if (x+dx[i] < 0) or (x+dx[i] >= n) or (y+dy[i] < 0) or (y+dy[i] >= n):
            continue
        if visited[x+dx[i]][y+dy[i]] == 0:
            if dangi[x+dx[i]][y+dy[i]] == 1:
                visited[x+dx[i]][y+dy[i]] = cnt
                result[cnt-1] += 1
                dfs(x+dx[i], y+dy[i], cnt)


n = int(input())
dangi = [list(map(int, input())) for _ in range(n)]
visited = [[0] * n for _ in range(n)]
result = []
cnt = 1

for i in range(n):
    for j in range(n):
        # 방문 안했을 경우
        if visited[i][j] == 0:
            # 집없는 경우
            if dangi[i][j] == 0:
                visited[i][j] = -1
            # 집있는 경우
            else:
                visited[i][j] = cnt
                result.append(1)
                dfs(i, j, cnt)
                cnt += 1

print(cnt-1)
# 정렬 필수!
print('\n'.join(map(str, sorted(result))))

```

|     결과     | 메모리(KB) | 시간(ms) |   언어   | 코드 길이(B) |
| :----------: | :--------: | :------: | :------: | :----------: |
| 맞았습니다!! |   31104    |    72    | Python 3 |     892      |

#### **📝해설**

**알고리즘**

```
1. 인덱스 순차적으로 방문하지 않았으면서 단지 내에서 아파트(숫자 1) 찾기
2. 찾으면 해당 인덱스부터 dfs 시작
3. dfs는 내부에서 위, 아래, 왼쪽, 오른쪽이 조건에 맞는지 확인
4. 조건에 의해 dfs를 호출한 만큼이 단지의 아파트 개수
4. dfs가 모두 끝나면 다시 1번부터 반복 (dfs를 다시 호출하게되면 다른 아파트 단지임)
```

사실 dfs 함수에 굳이 단지 번호를 받지 않아도 되고 visited도 굳이 단지별로 나누지 않아도 되는데 한번 그렇게 풀어봤다😅

`dfs(x, y)`같이 좌표값만 주어도 해결할 수 있다.

**주의할 점**

1. dfs 내부에서 탐색시에 **index range 조건** 확인해주기

    처음에는 try-except문으로 쉽게 오류 처리를 해주었다. 그런데 문제는 python의 list index 문법은 -1을 오류로 처리하지 않는다는 것이다. 그렇기 때문에 첫번째 입력 예시같은 경우는 모두 같은 단지로 처리해버리게 된다.

    try-except문을 사용하지말고 if문으로 index range 조건을 직접 처리해주자

2. **결과값 출력시 정렬하기**

    이건 문제 출력 조건에도 명시되어 있는데 문제가 잘 이해된다고 주의깊게 보지않고 문제를 풀었다가 이거 맞는데 왜 틀리지? ~~(이맞왜틀)~~ 했다.

    문제의 조건을 주의깊게 보자.

### **🔖정리**

1. **list index가 -1도 참조하는 것을 잊지 말자**
2. **문제의 조건을 주의 깊게 보자**
